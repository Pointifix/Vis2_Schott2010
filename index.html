<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - volume rendering example</title>
    <meta charset="utf-8">
    <meta content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
    <link href="main.css" rel="stylesheet" type="text/css">
</head>

<body>
<div id="info">
    <a href="https://threejs.org" rel="noopener" target="_blank">three.js</a> - Float volume render test (mip /
    isosurface)
</div>
<div id="container"></div>
<div id="inset"></div>
<script type="module">
    import * as THREE from './build/three.module.js';
    import {OrbitControls} from './js/controls/OrbitControls.js';
    import Stats from './js/libs/stats.module.js';
    import {WEBGL} from './js/WebGL.js';
    import {GUIManager} from "./js/GUIManager.js";
    import {VolumeManager} from "./js/VolumeManager.js";
    import {ProxyGeometryGenerator} from "./js/ProxyGeometryGenerator.js";
    import {DoFShader} from "./js/shaders/DoFShader/DoFShader.js";
    import {VolumeShader} from "./js/shaders/VolumeShader/VolumeShader.js";
    import * as CONSTANTS from "./js/Constants.js";

    if (WEBGL.isWebGL2Available() === false) {
        document.body.appendChild(WEBGL.getWebGL2ErrorMessage());
    }

    let renderer, camera, controls, stats, container;

    let guiManager;
    let volumeManager;
    let proxyGeometryGenerator;

    let dofShader;
    let dofShaderMaterial;

    let compositionShader;
    let compositionMaterial;

    let f2bRenderTargets = new Array(2);
    let f2bCurrentRenderTarget = false;

    let b2fRenderTargets = new Array(2);
    let b2fCurrentRenderTarget = false;

    let scenes = [CONSTANTS.MAX_SLICES_COUNT];

    let transferTextures;

    let quadCamera, quadMesh;

    init();
    animate();

    function init() {
        //Scenes
        for (let i = 0; i < CONSTANTS.MAX_SLICES_COUNT; i++) {
            scenes[i] = new THREE.Scene();
        }

        //Renderer
        container = document.getElementById("container");
        let canvas = document.createElement('canvas');
        let context = canvas.getContext('webgl2', {alpha: true, antialias: false});
        renderer = new THREE.WebGLRenderer({canvas: canvas, context: context, preserveDrawingBuffer: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        renderer.autoClear = false;

        //Camera
        let h = 512;
        let aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.OrthographicCamera(-h * aspect / 2, h * aspect / 2, h / 2, -h / 2, -1000, 1000);
        camera.prevZoom = Number.MAX_VALUE;

        //Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.update();

        //Volume Shader
        dofShader = DoFShader;
        let uniforms1 = THREE.UniformsUtils.clone(dofShader.uniforms);

        dofShaderMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms1,
            vertexShader: dofShader.vertexShader,
            fragmentShader: dofShader.fragmentShader,
            side: THREE.DoubleSide,
            transparent: true,
            depthTest: false
        });

        dofShaderMaterial.uniforms["u_screen_size"].value = new THREE.Vector2(window.innerWidth, window.innerHeight);

        //Composition Shader
        compositionShader = VolumeShader;
        let uniforms2 = THREE.UniformsUtils.clone(compositionShader.uniforms);

        compositionMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms2,
            vertexShader: VolumeShader.vertexShader,
            fragmentShader: VolumeShader.fragmentShader,
            side: THREE.DoubleSide,
            transparent: true,
            depthTest: false
        });

        compositionMaterial.uniforms["u_screen_size"].value = new THREE.Vector2(window.innerWidth, window.innerHeight);

        //Managers
        proxyGeometryGenerator = new ProxyGeometryGenerator();
        volumeManager = new VolumeManager(camera, controls, dofShaderMaterial);
        guiManager = new GUIManager();

        //Framebuffer
        f2bRenderTargets[0] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        f2bRenderTargets[1] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

        b2fRenderTargets[0] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        b2fRenderTargets[1] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

        let i = 0;
        proxyGeometryGenerator.geometries.forEach(geometry => {
            let proxyMesh = new THREE.Mesh(geometry, dofShaderMaterial);
            scenes[i].add(proxyMesh);
            i++;
        });

        //Transfer Functions
        transferTextures = {
            viridis: new THREE.TextureLoader().load('misc/textures/cm_viridis.png', render),
            gray: new THREE.TextureLoader().load('misc/textures/cm_gray.png', render)
        };

        compositionMaterial.uniforms["u_transfer"].value = transferTextures.gray;

        //Screen Quad
        quadCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
        quadMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), compositionMaterial );

        //Stats
        stats = new Stats();
        container.appendChild(stats.dom);

        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        let aspect = window.innerWidth / window.innerHeight;

        b2fRenderTargets[0] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        b2fRenderTargets[1] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

        f2bRenderTargets[0] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        f2bRenderTargets[1] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

        dofShaderMaterial.uniforms["u_screen_size"].value = new THREE.Vector2(window.innerWidth, window.innerHeight);
        compositionMaterial.uniforms["u_screen_size"].value = new THREE.Vector2(window.innerWidth, window.innerHeight);

        let frustumHeight = camera.top - camera.bottom;

        camera.left = -frustumHeight * aspect / 2;
        camera.right = frustumHeight * aspect / 2;

        camera.updateProjectionMatrix();
    }

    function animate() {
        requestAnimationFrame(animate);

        if (!(proxyGeometryGenerator.box === undefined)) proxyGeometryGenerator.updateProxyGeometries(camera);

        if (controls.update() || camera.zoom != camera.prevZoom) {
            render();
            stats.update();

            camera.prevZoom = camera.zoom;
        }
    }

    function render() {
        renderer.setRenderTarget(b2fRenderTargets[b2fCurrentRenderTarget | 0]);
        renderer.clear();
        renderer.setRenderTarget(b2fRenderTargets[!b2fCurrentRenderTarget | 0]);
        renderer.clear();
        renderer.setRenderTarget(f2bRenderTargets[f2bCurrentRenderTarget | 0]);
        renderer.clear();
        renderer.setRenderTarget(f2bRenderTargets[!f2bCurrentRenderTarget | 0]);
        renderer.clear();
        renderer.setRenderTarget(null);
        renderer.clear();

        dofShaderMaterial.uniforms["depthCoord"].value = guiManager.focplaneposValue;
        dofShaderMaterial.uniforms["circleOfConf"].value = guiManager.blurValue;

        //f2b
        for (let i = 0; i < proxyGeometryGenerator.focalPlaneIndex; i++) {
            dofShaderMaterial.uniforms["u_prev"].value = f2bRenderTargets[!f2bCurrentRenderTarget | 0].texture;
            dofShaderMaterial.uniforms["FRONT2BACK"].value = 1;

            renderer.setRenderTarget(f2bRenderTargets[f2bCurrentRenderTarget | 0]);

            renderer.render(scenes[i], camera);
            f2bCurrentRenderTarget = !f2bCurrentRenderTarget;
        }

        //b2f
        for (let i = proxyGeometryGenerator.sliceIndex; i >= proxyGeometryGenerator.focalPlaneIndex; i--) {

            dofShaderMaterial.uniforms["FRONT2BACK"].value = 0;
            dofShaderMaterial.uniforms["u_prev"].value = b2fRenderTargets[!b2fCurrentRenderTarget | 0].texture;

            renderer.setRenderTarget(b2fRenderTargets[b2fCurrentRenderTarget | 0]);

            renderer.render(scenes[i], camera);
            b2fCurrentRenderTarget = !b2fCurrentRenderTarget;
        }

        compositionMaterial.uniforms["u_f2b"].value = f2bRenderTargets[!f2bCurrentRenderTarget | 0].texture;
        compositionMaterial.uniforms["u_b2f"].value = b2fRenderTargets[!b2fCurrentRenderTarget | 0].texture;
        renderer.setRenderTarget(null);

        let mesh = scenes[proxyGeometryGenerator.focalPlaneIndex].children[0];
        scenes[proxyGeometryGenerator.focalPlaneIndex].remove(scenes[proxyGeometryGenerator.focalPlaneIndex].children[0]);

        scenes[proxyGeometryGenerator.focalPlaneIndex].add(new THREE.Mesh(mesh.geometry, compositionMaterial));

        renderer.render(quadMesh, quadCamera);

        scenes[proxyGeometryGenerator.focalPlaneIndex].remove(scenes[proxyGeometryGenerator.focalPlaneIndex].children[0]);
        scenes[proxyGeometryGenerator.focalPlaneIndex].add(mesh);

        stats.update();
    }
</script>
</body>
</html>
