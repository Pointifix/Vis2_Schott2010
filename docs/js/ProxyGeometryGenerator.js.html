

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      ProxyGeometryGenerator.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Braintree SDK Client Reference
    </h3>

    

    <h3>Classes</h3><ul><li id="GUIManager-nav"><a href="GUIManager.html">GUIManager</a><ul class='methods'><li data-type="method" id="GUIManager-updateBlur-nav"><a href="GUIManager.html#updateBlur">updateBlur</a></li><li data-type="method" id="GUIManager-updateBlur-nav"><a href="GUIManager.html#updateBlur">updateBlur</a></li><li data-type="method" id="GUIManager-updateFocus-nav"><a href="GUIManager.html#updateFocus">updateFocus</a></li><li data-type="method" id="GUIManager-updateFocus-nav"><a href="GUIManager.html#updateFocus">updateFocus</a></li><li data-type="method" id="GUIManager-updateMaxFocus-nav"><a href="GUIManager.html#updateMaxFocus">updateMaxFocus</a></li><li data-type="method" id="GUIManager-updateMaxFocus-nav"><a href="GUIManager.html#updateMaxFocus">updateMaxFocus</a></li><li data-type="method" id="GUIManager-updateThreshold-nav"><a href="GUIManager.html#updateThreshold">updateThreshold</a></li><li data-type="method" id="GUIManager-updateThreshold-nav"><a href="GUIManager.html#updateThreshold">updateThreshold</a></li><li data-type="method" id="GUIManager-updateTransfer-nav"><a href="GUIManager.html#updateTransfer">updateTransfer</a></li><li data-type="method" id="GUIManager-updateTransfer-nav"><a href="GUIManager.html#updateTransfer">updateTransfer</a></li><li data-type="method" id="GUIManager-updateVolume-nav"><a href="GUIManager.html#updateVolume">updateVolume</a></li><li data-type="method" id="GUIManager-updateVolume-nav"><a href="GUIManager.html#updateVolume">updateVolume</a></li></ul></li><li id="ProxyGeometryGenerator-nav"><a href="ProxyGeometryGenerator.html">ProxyGeometryGenerator</a><ul class='methods'><li data-type="method" id="ProxyGeometryGenerator-calcIntersection-nav"><a href="ProxyGeometryGenerator.html#calcIntersection">calcIntersection</a></li><li data-type="method" id="ProxyGeometryGenerator-calcIntersection-nav"><a href="ProxyGeometryGenerator.html#calcIntersection">calcIntersection</a></li><li data-type="method" id="ProxyGeometryGenerator-setBoundingBox-nav"><a href="ProxyGeometryGenerator.html#setBoundingBox">setBoundingBox</a></li><li data-type="method" id="ProxyGeometryGenerator-setBoundingBox-nav"><a href="ProxyGeometryGenerator.html#setBoundingBox">setBoundingBox</a></li><li data-type="method" id="ProxyGeometryGenerator-sortPolygonEdges-nav"><a href="ProxyGeometryGenerator.html#sortPolygonEdges">sortPolygonEdges</a></li><li data-type="method" id="ProxyGeometryGenerator-sortPolygonEdges-nav"><a href="ProxyGeometryGenerator.html#sortPolygonEdges">sortPolygonEdges</a></li><li data-type="method" id="ProxyGeometryGenerator-updateProxyGeometries-nav"><a href="ProxyGeometryGenerator.html#updateProxyGeometries">updateProxyGeometries</a></li><li data-type="method" id="ProxyGeometryGenerator-updateProxyGeometries-nav"><a href="ProxyGeometryGenerator.html#updateProxyGeometries">updateProxyGeometries</a></li></ul></li><li id="VolumeManager-nav"><a href="VolumeManager.html">VolumeManager</a><ul class='methods'><li data-type="method" id="VolumeManager-loadNRRDFile-nav"><a href="VolumeManager.html#loadNRRDFile">loadNRRDFile</a></li><li data-type="method" id="VolumeManager-loadNRRDFile-nav"><a href="VolumeManager.html#loadNRRDFile">loadNRRDFile</a></li><li data-type="method" id="VolumeManager-updateVolume-nav"><a href="VolumeManager.html#updateVolume">updateVolume</a></li><li data-type="method" id="VolumeManager-updateVolume-nav"><a href="VolumeManager.html#updateVolume">updateVolume</a></li></ul></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        ProxyGeometryGenerator.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import * as THREE from '../build/three.module.js';

import * as SHARED from "./Shared.js";

/**
 * @author David Ammer
 * @author Simon Pointner
 * @description Generates the Proxy-Geometry / https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-39-volume-rendering-techniques
 */

class ProxyGeometryGenerator {
    box;
    corners;
    edges;

    sliceIndex = 0;

    geometries = new Array(SHARED.MAX_SLICES_COUNT);

    constructor() {
        if (ProxyGeometryGenerator.exists) {
            return ProxyGeometryGenerator.instance;
        }
        ProxyGeometryGenerator.instance = this;
        ProxyGeometryGenerator.exists = true;

        for (let i = 0; i &lt; SHARED.MAX_SLICES_COUNT; i++) {
            this.geometries[i] = new THREE.BufferGeometry();

            this.geometries[i].setIndex(new Array(6 * 3).fill(0));
            this.geometries[i].setAttribute('position', new THREE.BufferAttribute(new Float32Array(7 * 3).fill(0), 3));
            this.geometries[i].setDrawRange({start: 0, count: 0});
        }

        return this;
    }

    /**
     * @param{THREE.Box3} box - the bounding box
     * @description Update bounding box.
     */
    setBoundingBox(box) {
        this.box = box;

        let min = box.min;
        let max = box.max;

        let minX = Math.min(min.x, max.x);
        let minY = Math.min(min.y, max.y);
        let minZ = Math.min(min.z, max.z);

        let maxX = Math.max(min.x, max.x);
        let maxY = Math.max(min.y, max.y);
        let maxZ = Math.max(min.z, max.z);

        this.corners = [
            new THREE.Vector3(minX, minY, minZ),
            new THREE.Vector3(maxX, minY, minZ),
            new THREE.Vector3(minX, maxY, minZ),
            new THREE.Vector3(maxX, maxY, minZ),
            new THREE.Vector3(minX, minY, maxZ),
            new THREE.Vector3(maxX, minY, maxZ),
            new THREE.Vector3(minX, maxY, maxZ),
            new THREE.Vector3(maxX, maxY, maxZ),
        ];

        this.edges = [
            new THREE.Line3(this.corners[0], this.corners[1]),
            new THREE.Line3(this.corners[2], this.corners[3]),
            new THREE.Line3(this.corners[4], this.corners[5]),
            new THREE.Line3(this.corners[6], this.corners[7]),

            new THREE.Line3(this.corners[0], this.corners[2]),
            new THREE.Line3(this.corners[1], this.corners[3]),
            new THREE.Line3(this.corners[4], this.corners[6]),
            new THREE.Line3(this.corners[5], this.corners[7]),

            new THREE.Line3(this.corners[0], this.corners[4]),
            new THREE.Line3(this.corners[1], this.corners[5]),
            new THREE.Line3(this.corners[2], this.corners[6]),
            new THREE.Line3(this.corners[3], this.corners[7])
        ];
    }

    /**
     * Returns the intersection point of a plane/line intersection
     * @param {THREE.Plane}plane - plane for slice
     * @param {THREE.Line3}line - intersection  line
     * @param {THREE.Vector3}vertices - vertices who intersect
     * @returns {boolean}
     */
    calcIntersection(plane, line, vertices) {
        let intersection = new THREE.Vector3();
        if (plane.intersectLine(line, intersection) === undefined) return false;
        vertices.push(intersection);
        return true;
    }

    /**
     * Calculates the proxy geometries created by intersection view aligned slices with the volume bounding box
     * @param {THREE.OrthographicCamera} camera - the orthographic camera
     * @returns {Array}
     */
    updateProxyGeometries(camera) {
        let intersectionVertices = [];

        let cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);

        let viewPlane = new THREE.Plane();
        viewPlane.setFromNormalAndCoplanarPoint(cameraDirection, camera.position);

        let plane = new THREE.Plane(cameraDirection, viewPlane.constant);

        let sliceIndex = 0;

        do {
            plane.constant -= window.sliceDistance;

            intersectionVertices = [];

            this.edges.forEach(line => {
                this.calcIntersection(plane, line, intersectionVertices);
            });

            if (intersectionVertices.length) {
                this.sortPolygonEdges(intersectionVertices);

                let geometry = this.geometries[sliceIndex];

                for (let i = 0; i &lt; intersectionVertices.length; i++) {
                    geometry.attributes.position.array[i * 3] = intersectionVertices[i].x;
                    geometry.attributes.position.array[i * 3 + 1] = intersectionVertices[i].y;
                    geometry.attributes.position.array[i * 3 + 2] = intersectionVertices[i].z;
                }

                for (let face = 0; face &lt; intersectionVertices.length - 1; face++) {
                    geometry.index.array[face * 3] = intersectionVertices.length - 1;
                    geometry.index.array[face * 3 + 1] = face;
                    geometry.index.array[face * 3 + 2] = (face + 1) % (intersectionVertices.length - 1);
                }

                geometry.setDrawRange(0, (intersectionVertices.length - 1) * 3);

                geometry.attributes.position.needsUpdate = true;
                geometry.index.needsUpdate= true;

                geometry.computeBoundingSphere();

                sliceIndex++;
            }
        } while ((intersectionVertices.length || sliceIndex == 0) &amp;&amp; sliceIndex &lt; SHARED.MAX_SLICES_COUNT);

        this.sliceIndex = sliceIndex;
    }


    /**
     * @description  Calculates the centroid of intersectionVertices, sorts the intersection Vertices according in ascending order of the angle
     * to the centroid, and adds the centroid at the end of intersectionVertices
     * @param{Array} intersectionVertices - intersection vertices
     */
    sortPolygonEdges(intersectionVertices) {
        let centroid = new THREE.Vector3(0, 0, 0);

        for (let i = 0; i &lt; intersectionVertices.length; i++) {
            centroid.add(intersectionVertices[i]);
        }
        centroid.divideScalar(intersectionVertices.length);

        let angles = [];
        for (let i = 0; i &lt; intersectionVertices.length; i++) {
            angles[i] = Math.atan2((intersectionVertices[i].y - centroid.y), (intersectionVertices[i].x - centroid.x));
        }

        intersectionVertices.sort(function (a, b) {
            return angles[intersectionVertices.indexOf(a)] - angles[intersectionVertices.indexOf(b)];
        });

        intersectionVertices.push(centroid);
    }
}

export {ProxyGeometryGenerator};
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
