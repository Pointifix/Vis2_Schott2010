<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - volume rendering example</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
<div id="info">
	<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Float volume render test (mip /
	isosurface)
</div>
<div id="inset"></div>

<script type="module">
	import * as THREE from './build/three.module.js';
	import {GUI} from './js/libs/dat.gui.module.js';
	import {OrbitControls} from './js/controls/OrbitControls.js';
	import {NRRDLoader} from './js/loaders/NRRDLoader.js';
	import {VolumeShader} from './js/shaders/VolumeShader/VolumeShader.js';
	import {ProxyGeometryGenerator} from './js/ProxyGeometryGenerator.js';

	import {WEBGL} from './js/WebGL.js';

	if (WEBGL.isWebGL2Available() === false) {
		document.body.appendChild(WEBGL.getWebGL2ErrorMessage());
	}

	//True: Show the focal plane
	//False: Hide focal plane
	var debugMode = false;


	var renderer, scene, camera, controls, material, volconfig, mesh, actualVol, focalPlane, focplaneposGUI,
			boundingBox, volumeMesh;
	let box;
	let proxyGeometries;


	var renderTextures = ['stent', 'skull', 'aneurism', 'teapot'];

	init();

	function init() {
		scene = new THREE.Scene();


		// Create renderer
		let canvas = document.createElement('canvas');
		let context = canvas.getContext('webgl2', {alpha: true, antialias: false});
		renderer = new THREE.WebGLRenderer({canvas: canvas, context: context});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		// Create camera (The volume renderer does not work very well with perspective yet)
		let h = 512; // frustum height
		let aspect = window.innerWidth / window.innerHeight;
/*		camera = new THREE.OrthographicCamera( - h * aspect / 2, h * aspect / 2, h / 2, - h / 2, 1, 1000 );
        camera.position.set( 0, 0, 0 );
        camera.up.set( 0, 0, 1 ); // In our data, z is up
        camera.updateProjectionMatrix();
*/
		//TODO: Perspektivische Kamera fÃ¼r slice blurring?
		camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 3000);
		camera.position.z = -300;

		// Create controls
		controls = new OrbitControls(camera, renderer.domElement);
		controls.addEventListener('change', render);
		controls.target.set(0, 0, 0);
		controls.minZoom = 0.5;
		controls.maxZoom = 4;
		controls.update();

		//Draw Point at Origin
		let dotGeometry = new THREE.Geometry();
		dotGeometry.vertices.push(new THREE.Vector3(0, 0, 0));
		let dotMaterial = new THREE.PointsMaterial({size: 1, sizeAttenuation: false});
		let dot = new THREE.Points(dotGeometry, dotMaterial);
		scene.add(dot);


		// The gui for interaction
		volconfig = {volume: 'stent', focplanepos: 64, 'Blur': 1};
		actualVol = "stent";
		let gui = new GUI();


		gui.add(volconfig, 'volume', renderTextures // { aneurism: 'aneurism', leg: 'leg' }
		).onChange(updateGUIValues);
		focplaneposGUI = gui.add(volconfig, 'focplanepos', 0, 200, 1).onChange(updateGUIValues);
		gui.add(volconfig, 'Blur', 0, 1, 0.01).onChange(updateGUIValues);


		// Load the data ...
		loadNRRDFile("models/nrrd/stent.nrrd", "stent");


		window.addEventListener('resize', onWindowResize, false);

	}


	/* Author: David
    *  Load NRRD-File and create Bounding-Box
    *  If we have a new mesh, remove the old one
    */
	function loadNRRDFile(filePath, file) {
		if (mesh != null) {
			scene.remove(mesh);
			scene.remove(boundingBox);
			scene.remove(focalPlane);
		}
		new NRRDLoader().load(filePath, function (volume) {


			var texture = new THREE.DataTexture3D(volume.data, volume.xLength, volume.yLength, volume.zLength);

			if (file == "stent") {
				texture.format = THREE.RedFormat;
				texture.type = THREE.FloatType;
			} else {
				texture.format = THREE.RedFormat;
			}

			texture.minFilter = texture.magFilter = THREE.LinearFilter;
			texture.unpackAlignment = 1;

			// Material
			let shader = VolumeShader;

			let uniforms = THREE.UniformsUtils.clone(shader.uniforms);

			uniforms["u_volume"].value = texture;
			uniforms["u_size"].value.set(volume.xLength, volume.yLength, volume.zLength);

			material = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: THREE.DoubleSide, // The volume shader uses the backface as its "reference point"
				opacity: 0.4,
				transparent: true
			});

			// THREE.Mesh
			box = new THREE.BoxBufferGeometry(volume.xLength, volume.yLength, volume.zLength);

			mesh = new THREE.Mesh(box, material);
			scene.add(mesh);

			//Create bounding box
			boundingBox = new THREE.BoxHelper(mesh, 0xff0000);
			boundingBox.update();
			scene.add(boundingBox);

			//Visual presentation of focal plane
			//createFocalPlane(volume.xLength, volume.yLength, volume.zLength );

			//Update gui for the focal plane
			focplaneposGUI = focplaneposGUI.min(1).max(volume.xLength).setValue(volume.xLength / 2);
			volconfig.focplanepos = volume.xLength / 2;
			volumeMesh = volume;

			proxyGeometries = new ProxyGeometryGenerator(box.boundingBox);
			render();

		});

	}

	/* Author: David
    * Update if a input-value changed
    */
	function updateGUIValues() {
		if (actualVol != volconfig.volume) {
			actualVol = volconfig.volume;
			switch (volconfig.volume) {
				case "teapot":
					loadNRRDFile("models/nrrd/teapot.nrrd", "teapot");
					break;
				case "skull":
					loadNRRDFile("models/nrrd/skull.nrrd", "skull");
					break;
				case "stent":
					loadNRRDFile("models/nrrd/stent.nrrd", "stent");
					break;
				case "aneurism":
					loadNRRDFile("models/nrrd/aneurism.nrrd", "aneurism");
					break;
				default:
					loadNRRDFile("models/nrrd/stent.nrrd", "stent");
			}

		}

		if (focalPlane != null) {
			focalPlane.position.set(volconfig.focplanepos, focalPlane.position.y, focalPlane.position.z);
		}
		render();

	}


	function onWindowResize() {

		renderer.setSize(window.innerWidth, window.innerHeight);
		var aspect = window.innerWidth / window.innerHeight;

		var frustumHeight = camera.top - camera.bottom;

		camera.left = -frustumHeight * aspect / 2;
		camera.right = frustumHeight * aspect / 2;

		camera.updateProjectionMatrix();

		render();

	}


	function render() {
		let points = [];
		let materialProxy = new THREE.PointsMaterial({
			color: 0x1ffff1
		});

		if (volumeMesh != null) {
			let proxGeos = proxyGeometries.updateProxyGeometries(camera, true);


			console.log("MATERIALS: ", material);
			proxGeos.forEach(element => {
				//	let mesh = new THREE.Mesh(element, new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true }));
				let mesh = new THREE.Mesh(element, material);
				scene.add(mesh);
				points.push(mesh);
			});
		}

		//glClear(GL_DEPTH_BUFFER_BIT);
		renderer.clear(renderer.DEPTH_BUFFER_BIT);
		renderer.render(scene, camera);

		points.forEach(element => {
			scene.remove(element);
		});
	}

	/* Author: David
        *  For DEBUGGING: Visualization of focal plane
    */
	function createFocalPlane(x, y, z) {
		let geometry = new THREE.PlaneGeometry(x, z, y);
		let opacity;

		if (debugMode == true) {
			opacity = 0.5;
		} else {
			opacity = 0.0;
		}
		let mat = new THREE.MeshBasicMaterial({
			color: 0xffff00,
			opacity: opacity,
			transparent: true,
			side: THREE.DoubleSide
		});

		focalPlane = new THREE.Mesh(geometry, mat);
		focalPlane.rotateX(Math.PI / 2);
		focalPlane.rotateY(Math.PI / 2);
		focalPlane.translateZ(y / 2);
		focalPlane.translateX(x / 2);

		focalPlane.translateY(z / 2);

		scene.add(focalPlane);
	}

</script>

</body>
</html>
